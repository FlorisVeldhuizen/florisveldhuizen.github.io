{"ast":null,"code":"var _jsxFileName = \"/Users/floris.veldhuizen/Documents/GitHub/florisveldhuizen.github.io/src/pages/FunkySnake.jsx\";\nimport React from \"react\";\nimport { ReactP5Wrapper } from \"react-p5-wrapper\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst sketch = p5 => {\n  /*\n  Made by: Floris Veldhuizen\n  Queuing of moves was adapted from: https://github.com/patorjk/JavaScript-Snake/blob/master/js/snake.js\n  */\n  // PARAMS\n  const fieldWidth = 400;\n  const fieldHeight = 400;\n  const backgroundColor = 255;\n  const gridResX = 14; // How many squares fit in a row  (default: 14)\n\n  const gameSpeed = 13; // Amount of frames per second    (default: 12)\n\n  const snakeSize = 5; // GLOBAL VARIABLES\n\n  const NIL = -1;\n  const _RIGHT = 0;\n  const _DOWN = 1;\n  const _LEFT = 2;\n  const _UP = 3; // PRECALCULATED VALUES\n\n  let fieldOffsetX, fieldOffsetY, squareSize, gridResY, maxLength, lastDir; // TOUCH CONTROLS\n\n  let startTouchX, startTouchY;\n  let touchControl = false; // If true, the touch controls are displayed on screen\n\n  let touchDir = NIL;\n  const arcSize = 120; // Diameter of the touch controls\n\n  let isFirstMove = true;\n  let preMove = NIL;\n  let curDir = _RIGHT;\n  let curLoc = [0, 0];\n  let bodyParts = [];\n  let bodyLength = snakeSize - 1;\n  let death = false;\n  let iterationCounter = 0;\n  let snaccPos = [0, 0];\n\n  let _frameRate = Math.floor(60 / gameSpeed); // Assuming 60 fps\n\n\n  let highScore = 0;\n\n  p5.setup = () => {\n    p5.createCanvas(p5.windowWidth, p5.windowHeight);\n    p5.background(0, 0, 0, 100);\n    fieldOffsetX = p5.windowWidth / 2 - fieldWidth / 2;\n    fieldOffsetY = p5.windowHeight / 2 - fieldHeight / 2;\n    squareSize = fieldWidth / gridResX;\n    gridResY = Math.floor(fieldHeight / squareSize);\n    maxLength = gridResX * gridResY;\n    spawnSnacc();\n  };\n\n  p5.draw = () => {\n    if (touchControl) calcTouch();\n\n    if (iterationCounter > _frameRate) {\n      p5.background(0, 0, 0, 100);\n      calcNewPos();\n      drawGrid();\n      drawPlayer();\n      drawSnacc();\n      iterationCounter = 0;\n    }\n\n    if (touchControl) drawTouch();\n    if (death) reset();\n    iterationCounter++;\n    drawScore();\n  };\n\n  const reset = () => {\n    p5.fill(255);\n    p5.rect(0, 0, p5.windowWidth, p5.windowHeight);\n    p5.background(0, 0, 0, 100);\n    bodyLength = snakeSize - 1;\n    bodyParts = [];\n    death = false;\n  };\n\n  const drawGrid = () => {\n    p5.stroke(255);\n    p5.fill(0);\n\n    for (let i = 0; i < gridResX; i++) {\n      // x-axis\n      for (let j = 0; j < gridResY; j++) {\n        // y-axis\n        p5.rect(i * squareSize + fieldOffsetX, j * squareSize + fieldOffsetY, squareSize, squareSize);\n      }\n    }\n  };\n\n  const drawScore = () => {\n    const fontSize = 30;\n    const curScore = bodyLength - (snakeSize - 1);\n    if (curScore > highScore) highScore = curScore;\n    p5.textSize(fontSize);\n    p5.fill(255); // Highscore\n\n    p5.textAlign(p5.RIGHT);\n    p5.text(`${String.fromCodePoint(0x1F3C6)}: ${highScore}`, fieldOffsetX + fieldWidth, fieldOffsetY - fontSize); // Current score\n\n    p5.textAlign(p5.LEFT);\n    p5.text(`${String.fromCodePoint(0x1F36C)}: ${curScore}`, fieldOffsetX, fieldOffsetY - fontSize);\n  };\n\n  const spawnSnacc = () => {\n    // TO-DO: use maxLength to determine when the game is over\n    const returnRandomPos = () => {\n      const xPos = Math.floor(Math.random() * gridResX);\n      const yPos = Math.floor(Math.random() * gridResY);\n      const overlap = bodyParts.some(part => part[0] === xPos && part[1] === yPos);\n      return overlap ? returnRandomPos() : [xPos, yPos];\n    };\n\n    const returnAvailablePos = () => {\n      const gridObject = {};\n      [...Array(gridResX)].forEach((_, i) => gridObject[i] = [...Array(gridResY).keys()]);\n\n      for (const [key, value] of Object.entries(gridObject)) {\n        const keyInt = parseInt(key);\n        gridObject[key] = value.filter(elem => !bodyParts.some(part => part[0] === keyInt && part[1] === elem));\n        if (gridObject[key].length < 1) delete gridObject[key];\n      }\n\n      const availableKeys = Object.keys(gridObject);\n      const availableX = parseInt(availableKeys[Math.floor(Math.random() * availableKeys.length)]);\n      const availableY = gridObject[availableX][Math.floor(Math.random() * gridObject[availableX].length)];\n      return [availableX, availableY];\n    };\n\n    return snaccPos = bodyLength < maxLength / 2 ? returnRandomPos() : returnAvailablePos();\n  };\n\n  const drawSnacc = () => {\n    p5.textSize(32);\n    p5.text(`${String.fromCodePoint(0x1F36C)}`, snaccPos[0] * squareSize + fieldOffsetX, (snaccPos[1] + 0.9) * squareSize + fieldOffsetY);\n  };\n\n  const calcNewPos = () => {\n    // Set lastDir and check for queued moves\n    lastDir = curDir;\n\n    if (preMove !== NIL) {\n      curDir = preMove;\n      preMove = NIL;\n    }\n\n    isFirstMove = true; // Calculate new position of body based on direction\n\n    if (lastDir === _UP) {\n      curLoc[1]--;\n    } else if (lastDir === _DOWN) {\n      curLoc[1]++;\n    } else if (lastDir === _LEFT) {\n      curLoc[0]--;\n    } else if (lastDir === _RIGHT) {\n      curLoc[0]++;\n    } // Boundary check\n\n\n    if (curLoc[1] < 0) {\n      curLoc[1] = gridResY - 1;\n    } else if (curLoc[1] > gridResY - 1) {\n      curLoc[1] = 0;\n    } else if (curLoc[0] < 0) {\n      curLoc[0] = gridResX - 1;\n    } else if (curLoc[0] > gridResX - 1) {\n      curLoc[0] = 0;\n    } // Shift the snake body\n\n\n    if (bodyParts.length > bodyLength) {\n      bodyParts.shift();\n    } // Death ðŸ’€ check\n\n\n    bodyParts.forEach(part => {\n      if (curLoc[0] === part[0] && curLoc[1] === part[1]) {\n        death = true;\n        console.error(`U DEAD ${String.fromCodePoint(0x1F480)}`);\n      }\n    }); // Set all bodyparts\n\n    bodyParts.push([...curLoc]); // Snacc ðŸ¬ check\n\n    if (curLoc[0] === snaccPos[0] && curLoc[1] === snaccPos[1]) {\n      bodyLength++;\n      spawnSnacc();\n    }\n  };\n\n  const drawPlayer = () => {\n    const colorInterval = Math.floor(155 / bodyLength);\n    bodyParts.forEach((part, index) => {\n      p5.fill(index * colorInterval + 100, 0, 0);\n      p5.rect(part[0] * squareSize + fieldOffsetX, part[1] * squareSize + fieldOffsetY, squareSize, squareSize);\n    });\n  };\n\n  const setDirection = dir => {\n    if (curDir !== lastDir) {\n      preMove = dir;\n    }\n\n    if (Math.abs(dir - lastDir) !== 2 && isFirstMove) {\n      curDir = dir;\n      isFirstMove = false;\n    }\n\n    touchDir = dir;\n  };\n\n  const calcTouch = () => {\n    const distSquared = (x1, y1, x2, y2) => {\n      let dx = x2 - x1;\n      let dy = y2 - y1;\n      return dx * dx + dy * dy;\n    };\n\n    let radianDistance = Math.atan2(p5.mouseY - startTouchY, p5.mouseX - startTouchX);\n    if (radianDistance < 0) radianDistance = radianDistance + p5.TWO_PI;\n\n    if (distSquared(startTouchX, startTouchY, p5.mouseX, p5.mouseY) > 100) {\n      if (radianDistance > p5.TWO_PI - p5.QUARTER_PI || radianDistance < p5.QUARTER_PI) {\n        setDirection(_RIGHT);\n      } else if (radianDistance > p5.QUARTER_PI && radianDistance < p5.HALF_PI + p5.QUARTER_PI) {\n        setDirection(_DOWN);\n      } else if (radianDistance > p5.HALF_PI + p5.QUARTER_PI && radianDistance < p5.PI + p5.QUARTER_PI) {\n        setDirection(_LEFT);\n      } else if (radianDistance > p5.PI + p5.QUARTER_PI && radianDistance < p5.TWO_PI - p5.QUARTER_PI) {\n        setDirection(_UP);\n      }\n    } else {\n      touchDir = NIL;\n    }\n  };\n\n  const drawTouch = () => {\n    const bottomArc = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.QUARTER_PI, p5.HALF_PI + p5.QUARTER_PI);\n\n    const leftArc = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.HALF_PI + p5.QUARTER_PI, p5.PI + p5.QUARTER_PI);\n\n    const topArc = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.PI + p5.QUARTER_PI, p5.TWO_PI - p5.QUARTER_PI);\n\n    const rightArc = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.TWO_PI - p5.QUARTER_PI, p5.QUARTER_PI);\n\n    p5.fill(100);\n    p5.ellipse(startTouchX, startTouchY, arcSize, arcSize);\n    p5.fill(200);\n    if (touchDir === _UP) topArc();\n    if (touchDir === _DOWN) bottomArc();\n    if (touchDir === _LEFT) leftArc();\n    if (touchDir === _RIGHT) rightArc(); // TO-DO: DRAW JOYSTICK THAT IS constrained BY BOUNDARIES OF CONTROL\n\n    p5.fill(50);\n    p5.ellipse(p5.mouseX, p5.mouseY, arcSize / 2, arcSize / 2);\n  };\n\n  const handleTouchEnd = () => {\n    touchControl = false;\n    return false;\n  };\n\n  const handleTouchBegin = () => {\n    startTouchX = p5.mouseX;\n    startTouchY = p5.mouseY;\n    touchControl = true;\n    return false;\n  };\n\n  const handleKeys = (keyType, up, down, left, right) => {\n    if (keyType === right) {\n      setDirection(_RIGHT);\n    }\n\n    if (keyType === down) {\n      setDirection(_DOWN);\n    }\n\n    if (keyType === left) {\n      setDirection(_LEFT);\n    }\n\n    if (keyType === up) {\n      setDirection(_UP);\n    }\n  };\n\n  p5.mousePressed = () => {\n    return handleTouchBegin();\n  };\n\n  p5.touchStarted = () => {\n    return handleTouchBegin();\n  };\n\n  p5.mouseReleased = () => {\n    return handleTouchEnd();\n  };\n\n  p5.touchEnded = () => {\n    return handleTouchEnd();\n  };\n\n  p5.keyTyped = () => {\n    handleKeys(p5.key, \"w\", \"s\", \"a\", \"d\");\n  };\n\n  p5.keyPressed = () => {\n    handleKeys(p5.keyCode, p5.UP_ARROW, p5.DOWN_ARROW, p5.LEFT_ARROW, p5.RIGHT_ARROW);\n  };\n\n  p5.windowResized = () => {\n    p5.resizeCanvas(p5.windowWidth, p5.windowHeight);\n    p5.background(0, 0, 0, 100);\n    fieldOffsetX = p5.windowWidth / 2 - fieldWidth / 2;\n    fieldOffsetY = p5.windowHeight / 2 - fieldHeight / 2;\n    squareSize = fieldWidth / gridResX;\n  };\n};\n\nconst FunkySnake = () => {\n  return /*#__PURE__*/_jsxDEV(ReactP5Wrapper, {\n    sketch: sketch\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 289,\n    columnNumber: 9\n  }, this);\n};\n\n_c = FunkySnake;\nexport default FunkySnake;\n\nvar _c;\n\n$RefreshReg$(_c, \"FunkySnake\");","map":{"version":3,"sources":["/Users/floris.veldhuizen/Documents/GitHub/florisveldhuizen.github.io/src/pages/FunkySnake.jsx"],"names":["React","ReactP5Wrapper","sketch","p5","fieldWidth","fieldHeight","backgroundColor","gridResX","gameSpeed","snakeSize","NIL","_RIGHT","_DOWN","_LEFT","_UP","fieldOffsetX","fieldOffsetY","squareSize","gridResY","maxLength","lastDir","startTouchX","startTouchY","touchControl","touchDir","arcSize","isFirstMove","preMove","curDir","curLoc","bodyParts","bodyLength","death","iterationCounter","snaccPos","_frameRate","Math","floor","highScore","setup","createCanvas","windowWidth","windowHeight","background","spawnSnacc","draw","calcTouch","calcNewPos","drawGrid","drawPlayer","drawSnacc","drawTouch","reset","drawScore","fill","rect","stroke","i","j","fontSize","curScore","textSize","textAlign","RIGHT","text","String","fromCodePoint","LEFT","returnRandomPos","xPos","random","yPos","overlap","some","part","returnAvailablePos","gridObject","Array","forEach","_","keys","key","value","Object","entries","keyInt","parseInt","filter","elem","length","availableKeys","availableX","availableY","shift","console","error","push","colorInterval","index","setDirection","dir","abs","distSquared","x1","y1","x2","y2","dx","dy","radianDistance","atan2","mouseY","mouseX","TWO_PI","QUARTER_PI","HALF_PI","PI","bottomArc","arc","leftArc","topArc","rightArc","ellipse","handleTouchEnd","handleTouchBegin","handleKeys","keyType","up","down","left","right","mousePressed","touchStarted","mouseReleased","touchEnded","keyTyped","keyPressed","keyCode","UP_ARROW","DOWN_ARROW","LEFT_ARROW","RIGHT_ARROW","windowResized","resizeCanvas","FunkySnake"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { ReactP5Wrapper } from \"react-p5-wrapper\";\n\nconst sketch = (p5) => {\n  /*\n  Made by: Floris Veldhuizen\n  Queuing of moves was adapted from: https://github.com/patorjk/JavaScript-Snake/blob/master/js/snake.js\n  */\n\n  // PARAMS\n  const fieldWidth = 400;\n  const fieldHeight = 400;\n  const backgroundColor = 255;\n  const gridResX = 14;          // How many squares fit in a row  (default: 14)\n  const gameSpeed = 13;         // Amount of frames per second    (default: 12)\n  const snakeSize = 5;\n\n  // GLOBAL VARIABLES\n  const NIL     = -1;\n  const _RIGHT  = 0;\n  const _DOWN   = 1;\n  const _LEFT   = 2;\n  const _UP     = 3;\n\n  // PRECALCULATED VALUES\n  let fieldOffsetX, fieldOffsetY, squareSize, gridResY, maxLength, lastDir;\n\n  // TOUCH CONTROLS\n  let startTouchX, startTouchY;\n  let touchControl = false;     // If true, the touch controls are displayed on screen\n  let touchDir = NIL;\n  const arcSize = 120;          // Diameter of the touch controls\n\n  let isFirstMove = true;\n  let preMove = NIL;\n  let curDir = _RIGHT;\n  let curLoc = [0,0];\n  let bodyParts = [];\n  let bodyLength = snakeSize - 1;\n  let death = false;\n  let iterationCounter = 0;\n  let snaccPos = [0,0];\n  let _frameRate = Math.floor(60 / gameSpeed); // Assuming 60 fps\n  let highScore = 0;\n\n  p5.setup = () => {\n    p5.createCanvas(p5.windowWidth, p5.windowHeight);\n    p5.background(0,0,0,100);\n    fieldOffsetX = (p5.windowWidth/2)-(fieldWidth/2);\n    fieldOffsetY = (p5.windowHeight/2)-(fieldHeight/2);\n    squareSize = fieldWidth / gridResX;\n    gridResY = Math.floor(fieldHeight / squareSize);\n    maxLength = gridResX * gridResY;\n    spawnSnacc();\n  }\n\n  p5.draw = () => {\n    if (touchControl) calcTouch();\n    if (iterationCounter > _frameRate) {\n      p5.background(0,0,0,100);\n      calcNewPos();\n      drawGrid();\n      drawPlayer();\n      drawSnacc();\n      iterationCounter = 0;\n    }\n    if (touchControl) drawTouch();\n    if (death) reset();\n    iterationCounter++;\n    drawScore();\n  }\n\n  const reset = () => {\n    p5.fill(255);\n    p5.rect(0,0,p5.windowWidth,p5.windowHeight);\n    p5.background(0,0,0,100);\n    bodyLength = snakeSize - 1;\n    bodyParts = [];\n    death = false;\n  }\n\n  const drawGrid = () => {\n    p5.stroke(255)\n    p5.fill(0);\n    for (let i = 0; i < gridResX; i++) { // x-axis\n      for (let j = 0; j < gridResY; j++) { // y-axis\n        p5.rect(i * squareSize + fieldOffsetX, j * squareSize + fieldOffsetY, squareSize, squareSize);\n      }\n    }\n  }\n\n  const drawScore = () => {\n    const fontSize = 30;\n    const curScore = bodyLength - (snakeSize - 1);\n    if(curScore > highScore) highScore = curScore;\n    p5.textSize(fontSize);\n    p5.fill(255)\n    // Highscore\n    p5.textAlign(p5.RIGHT);\n    p5.text(`${String.fromCodePoint(0x1F3C6)}: ${highScore}`, fieldOffsetX + fieldWidth, fieldOffsetY - fontSize);\n    // Current score\n    p5.textAlign(p5.LEFT);\n    p5.text(`${String.fromCodePoint(0x1F36C)}: ${curScore}`, fieldOffsetX, fieldOffsetY - fontSize);\n  }\n\n  const spawnSnacc = () => {\n    // TO-DO: use maxLength to determine when the game is over\n    const returnRandomPos = () => {\n      const xPos = Math.floor(Math.random() * gridResX);\n      const yPos = Math.floor(Math.random() * gridResY);\n      const overlap = bodyParts.some(part => (part[0] === xPos && part[1] === yPos));\n      return overlap ? returnRandomPos() : [xPos, yPos];\n    }\n\n    const returnAvailablePos = () => {\n      const gridObject = {};\n      [...Array(gridResX)].forEach((_,i) => gridObject[i] = [...Array(gridResY).keys()]);\n      for (const [key, value] of Object.entries(gridObject)) {\n        const keyInt = parseInt(key);\n        gridObject[key] = value.filter(elem =>\n          !bodyParts.some(part => part[0] === keyInt && part[1] === elem)\n        )\n        if (gridObject[key].length < 1) delete gridObject[key];\n      }\n      const availableKeys = Object.keys(gridObject);\n      const availableX = parseInt(availableKeys[Math.floor(Math.random() * availableKeys.length)]);\n      const availableY = gridObject[availableX][Math.floor(Math.random() * gridObject[availableX].length)];\n      return [availableX, availableY];\n    }\n\n  return snaccPos = bodyLength < maxLength / 2 ? returnRandomPos() : returnAvailablePos();\n  }\n\n  const drawSnacc = () => {\n    p5.textSize(32);\n    p5.text(`${String.fromCodePoint(0x1F36C)}`, snaccPos[0] * squareSize + fieldOffsetX, (snaccPos[1] + 0.9) * squareSize + fieldOffsetY);\n  }\n\n  const calcNewPos = () => {\n    // Set lastDir and check for queued moves\n    lastDir = curDir;\n    if (preMove !== NIL) {\n      curDir = preMove;\n      preMove = NIL;\n    }\n    isFirstMove = true;\n\n    // Calculate new position of body based on direction\n    if      (lastDir === _UP)    { curLoc[1]-- }\n    else if (lastDir === _DOWN)  { curLoc[1]++ }\n    else if (lastDir === _LEFT)  { curLoc[0]-- }\n    else if (lastDir === _RIGHT) { curLoc[0]++ }\n\n    // Boundary check\n    if      (curLoc[1] < 0) { curLoc[1] = gridResY - 1 }\n    else if (curLoc[1] > gridResY - 1) { curLoc[1] = 0 }\n    else if (curLoc[0] < 0) { curLoc[0] = gridResX - 1 }\n    else if (curLoc[0] > gridResX - 1) { curLoc[0] = 0 }\n\n    // Shift the snake body\n    if (bodyParts.length > bodyLength) { bodyParts.shift(); }\n\n    // Death ðŸ’€ check\n    bodyParts.forEach(part => {\n      if (curLoc[0] === part[0] && curLoc[1] === part[1]) {\n      death = true;\n      console.error(`U DEAD ${String.fromCodePoint(0x1F480)}`);\n      }\n    });\n\n    // Set all bodyparts\n    bodyParts.push([...curLoc]);\n\n    // Snacc ðŸ¬ check\n    if (curLoc[0] === snaccPos[0] && curLoc[1] === snaccPos[1]) {\n      bodyLength++;\n      spawnSnacc();\n    }\n  }\n\n  const drawPlayer = () => {\n    const colorInterval = Math.floor(155 / bodyLength);\n    bodyParts.forEach((part,index) => {\n      p5.fill(index * colorInterval + 100,0,0);\n      p5.rect(part[0] * squareSize + fieldOffsetX, part[1] * squareSize + fieldOffsetY, squareSize, squareSize);\n    });\n  }\n\n  const setDirection = dir => {\n    if (curDir !== lastDir) { preMove = dir }\n    if (Math.abs(dir - lastDir) !== 2 && isFirstMove) {\n      curDir = dir;\n      isFirstMove = false;\n    }\n    touchDir = dir;\n  }\n\n  const calcTouch = () => {\n    const distSquared = (x1, y1, x2, y2) => {\n      let dx = x2 - x1;\n      let dy = y2 - y1;\n      return dx * dx + dy * dy;\n    }\n    let radianDistance = Math.atan2(p5.mouseY-startTouchY, p5.mouseX-startTouchX);\n    if (radianDistance < 0) radianDistance = radianDistance + p5.TWO_PI;\n    if(distSquared(startTouchX, startTouchY, p5.mouseX, p5.mouseY) > 100) {\n      if      (radianDistance > p5.TWO_PI - p5.QUARTER_PI || radianDistance < p5.QUARTER_PI)          { setDirection(_RIGHT)}\n      else if (radianDistance > p5.QUARTER_PI && radianDistance < p5.HALF_PI + p5.QUARTER_PI)         { setDirection(_DOWN) }\n      else if (radianDistance > p5.HALF_PI + p5.QUARTER_PI && radianDistance < p5.PI + p5.QUARTER_PI) { setDirection(_LEFT) }\n      else if (radianDistance > p5.PI + p5.QUARTER_PI && radianDistance < p5.TWO_PI - p5.QUARTER_PI)  { setDirection(_UP)   }\n    } else {\n      touchDir = NIL;\n    }\n  }\n\n  const drawTouch = () => {\n    const bottomArc = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.QUARTER_PI, p5.HALF_PI + p5.QUARTER_PI);\n    const leftArc   = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.HALF_PI + p5.QUARTER_PI, p5.PI + p5.QUARTER_PI);\n    const topArc    = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.PI + p5.QUARTER_PI, p5.TWO_PI - p5.QUARTER_PI);\n    const rightArc  = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.TWO_PI - p5.QUARTER_PI, p5.QUARTER_PI);\n\n    p5.fill(100);\n    p5.ellipse(startTouchX, startTouchY, arcSize, arcSize);\n    p5.fill(200);\n    if (touchDir === _UP)    topArc();\n    if (touchDir === _DOWN)  bottomArc();\n    if (touchDir === _LEFT)  leftArc();\n    if (touchDir === _RIGHT) rightArc();\n\n    // TO-DO: DRAW JOYSTICK THAT IS constrained BY BOUNDARIES OF CONTROL\n    p5.fill(50);\n    p5.ellipse(p5.mouseX, p5.mouseY, arcSize/2, arcSize/2);\n  }\n\n  const handleTouchEnd = () => {\n    touchControl = false;\n    return false;\n  }\n\n  const handleTouchBegin = () => {\n    startTouchX = p5.mouseX;\n    startTouchY = p5.mouseY;\n    touchControl = true;\n    return false;\n  }\n\n  const handleKeys = (keyType, up, down, left, right) => {\n    if (keyType === right) { setDirection(_RIGHT)}\n    if (keyType === down)  { setDirection(_DOWN) }\n    if (keyType === left)  { setDirection(_LEFT) }\n    if (keyType === up)    { setDirection(_UP)   }\n  }\n\n  p5.mousePressed = () => {\n    return handleTouchBegin();\n  }\n\n  p5.touchStarted = () => {\n    return handleTouchBegin();\n  }\n\n  p5.mouseReleased = () => {\n    return handleTouchEnd();\n  }\n\n  p5.touchEnded = () => {\n    return handleTouchEnd();\n  }\n\n  p5.keyTyped = () => {\n    handleKeys(p5.key, \"w\", \"s\", \"a\", \"d\");\n  }\n\n  p5.keyPressed = () => {\n    handleKeys(p5.keyCode, p5.UP_ARROW, p5.DOWN_ARROW, p5.LEFT_ARROW, p5.RIGHT_ARROW);\n  }\n\n  p5.windowResized = () => {\n    p5.resizeCanvas(p5.windowWidth, p5.windowHeight);\n    p5.background(0,0,0,100);\n    fieldOffsetX = (p5.windowWidth/2)-(fieldWidth/2);\n    fieldOffsetY = (p5.windowHeight/2)-(fieldHeight/2);\n    squareSize = fieldWidth / gridResX;\n  }\n}\n\nconst FunkySnake = () => {\n    return (\n        <ReactP5Wrapper sketch={sketch} />\n    );\n};\n\nexport default FunkySnake;\n"]},"metadata":{},"sourceType":"module"}