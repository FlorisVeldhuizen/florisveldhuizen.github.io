{"ast":null,"code":"var _jsxFileName = \"/Users/floris.veldhuizen/Documents/GitHub/florisveldhuizen.github.io/src/pages/FunkySnake.jsx\",\n    _s = $RefreshSig$();\n\nimport { useEffect } from \"react\";\nimport { ReactP5Wrapper } from \"react-p5-wrapper\";\nimport { Helmet } from \"react-helmet-async\";\nimport { cleanupFavicon, P5Wrapper } from \"./helper\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nconst sketch = p5 => {\n  /*\n  Made by: Floris Veldhuizen\n  Queuing of moves was adapted from: https://github.com/patorjk/JavaScript-Snake/blob/master/js/snake.js\n  */\n  // PARAMS\n  const fieldWidth = 400;\n  const fieldHeight = 400;\n  const gridResX = 14; // How many squares fit in a row  (default: 14)\n\n  const gameSpeed = 13; // Amount of frames per second    (default: 12)\n\n  const snakeSize = 5; // GLOBAL VARIABLES\n\n  const NIL = -1;\n  const _RIGHT = 0;\n  const _DOWN = 1;\n  const _LEFT = 2;\n  const _UP = 3; // PRECALCULATED VALUES\n\n  let fieldOffsetX, fieldOffsetY, squareSize, gridResY, maxLength, lastDir; // TOUCH CONTROLS\n\n  let startTouchX, startTouchY;\n  let touchControl = false; // If true, the touch controls are displayed on screen\n\n  let touchDir = NIL;\n  const arcSize = 120; // Diameter of the touch controls\n\n  let isFirstMove = true;\n  let preMove = NIL;\n  let curDir = _RIGHT;\n  let curLoc = [0, 0];\n  let bodyParts = [];\n  let bodyLength = snakeSize - 1;\n  let death = false;\n  let iterationCounter = 0;\n  let snaccPos = [0, 0];\n\n  let _frameRate = Math.floor(60 / gameSpeed); // Assuming 60 fps\n\n\n  let highScore = 0;\n\n  p5.setup = () => {\n    p5.frameRate(60);\n    p5.createCanvas(p5.windowWidth, p5.windowHeight);\n    p5.background(0, 0, 0, 100);\n    fieldOffsetX = p5.windowWidth / 2 - fieldWidth / 2;\n    fieldOffsetY = p5.windowHeight / 2 - fieldHeight / 2;\n    squareSize = fieldWidth / gridResX;\n    gridResY = Math.floor(fieldHeight / squareSize);\n    maxLength = gridResX * gridResY;\n    spawnSnacc();\n  };\n\n  p5.draw = () => {\n    if (touchControl) calcTouch();\n\n    if (iterationCounter > _frameRate) {\n      p5.background(0, 0, 0, 100);\n      calcNewPos();\n      drawGrid();\n      drawPlayer();\n      drawSnacc();\n      iterationCounter = 0;\n    }\n\n    if (touchControl) drawTouch();\n    if (death) reset();\n    iterationCounter++;\n    drawScore();\n  };\n\n  const reset = () => {\n    p5.fill(255);\n    p5.rect(0, 0, p5.windowWidth, p5.windowHeight);\n    p5.background(0, 0, 0, 100);\n    bodyLength = snakeSize - 1;\n    bodyParts = [];\n    death = false;\n  };\n\n  const drawGrid = () => {\n    p5.stroke(255);\n    p5.fill(0);\n\n    for (let i = 0; i < gridResX; i++) {\n      // x-axis\n      for (let j = 0; j < gridResY; j++) {\n        // y-axis\n        p5.rect(i * squareSize + fieldOffsetX, j * squareSize + fieldOffsetY, squareSize, squareSize);\n      }\n    }\n  };\n\n  const drawScore = () => {\n    const fontSize = 30;\n    const curScore = bodyLength - (snakeSize - 1);\n    if (curScore > highScore) highScore = curScore;\n    p5.textSize(fontSize);\n    p5.fill(255); // Highscore\n\n    p5.textAlign(p5.RIGHT);\n    p5.text(`${String.fromCodePoint(0x1F3C6)}: ${highScore}`, fieldOffsetX + fieldWidth, fieldOffsetY - fontSize); // Current score\n\n    p5.textAlign(p5.LEFT);\n    p5.text(`${String.fromCodePoint(0x1F36C)}: ${curScore}`, fieldOffsetX, fieldOffsetY - fontSize);\n  };\n\n  const spawnSnacc = () => {\n    // TO-DO: use maxLength to determine when the game is over\n    const returnRandomPos = () => {\n      const xPos = Math.floor(Math.random() * gridResX);\n      const yPos = Math.floor(Math.random() * gridResY);\n      const overlap = bodyParts.some(part => part[0] === xPos && part[1] === yPos);\n      return overlap ? returnRandomPos() : [xPos, yPos];\n    };\n\n    const returnAvailablePos = () => {\n      const gridObject = {};\n      const copyParts = [...bodyParts];\n      [...Array(gridResX)].forEach((_, i) => gridObject[i] = [...Array(gridResY).keys()]);\n\n      for (const [key, value] of Object.entries(gridObject)) {\n        const keyInt = parseInt(key);\n        gridObject[key] = value.filter(elem => !copyParts.some(part => part[0] === keyInt && part[1] === elem));\n        if (gridObject[key].length < 1) delete gridObject[key];\n      }\n\n      const availableKeys = Object.keys(gridObject);\n      const availableX = parseInt(availableKeys[Math.floor(Math.random() * availableKeys.length)]);\n      const availableY = gridObject[availableX][Math.floor(Math.random() * gridObject[availableX].length)];\n      return [availableX, availableY];\n    };\n\n    return snaccPos = bodyLength < maxLength / 2 ? returnRandomPos() : returnAvailablePos();\n  };\n\n  const drawSnacc = () => {\n    p5.textSize(32);\n    p5.text(`${String.fromCodePoint(0x1F36C)}`, snaccPos[0] * squareSize + fieldOffsetX, (snaccPos[1] + 0.9) * squareSize + fieldOffsetY);\n  };\n\n  const calcNewPos = () => {\n    // Set lastDir and check for queued moves\n    lastDir = curDir;\n\n    if (preMove !== NIL) {\n      curDir = preMove;\n      preMove = NIL;\n    }\n\n    isFirstMove = true; // Calculate new position of body based on direction\n\n    if (lastDir === _UP) {\n      curLoc[1]--;\n    } else if (lastDir === _DOWN) {\n      curLoc[1]++;\n    } else if (lastDir === _LEFT) {\n      curLoc[0]--;\n    } else if (lastDir === _RIGHT) {\n      curLoc[0]++;\n    } // Boundary check\n\n\n    if (curLoc[1] < 0) {\n      curLoc[1] = gridResY - 1;\n    } else if (curLoc[1] > gridResY - 1) {\n      curLoc[1] = 0;\n    } else if (curLoc[0] < 0) {\n      curLoc[0] = gridResX - 1;\n    } else if (curLoc[0] > gridResX - 1) {\n      curLoc[0] = 0;\n    } // Shift the snake body\n\n\n    if (bodyParts.length > bodyLength) {\n      bodyParts.shift();\n    } // Death 💀 check\n\n\n    bodyParts.forEach(part => {\n      if (curLoc[0] === part[0] && curLoc[1] === part[1]) {\n        death = true;\n        console.error(`U DEAD ${String.fromCodePoint(0x1F480)}`);\n      }\n    }); // Set all bodyparts\n\n    bodyParts.push([...curLoc]); // Snacc 🍬 check\n\n    if (curLoc[0] === snaccPos[0] && curLoc[1] === snaccPos[1]) {\n      bodyLength++;\n      spawnSnacc();\n    }\n  };\n\n  const drawPlayer = () => {\n    const colorInterval = Math.floor(155 / bodyLength);\n    bodyParts.forEach((part, index) => {\n      p5.fill(index * colorInterval + 100, 0, 0);\n      p5.rect(part[0] * squareSize + fieldOffsetX, part[1] * squareSize + fieldOffsetY, squareSize, squareSize);\n    });\n  };\n\n  const setDirection = dir => {\n    if (curDir !== lastDir) {\n      preMove = dir;\n    }\n\n    if (Math.abs(dir - lastDir) !== 2 && isFirstMove) {\n      curDir = dir;\n      isFirstMove = false;\n    }\n\n    touchDir = dir;\n  };\n\n  const calcTouch = () => {\n    const distSquared = (x1, y1, x2, y2) => {\n      let dx = x2 - x1;\n      let dy = y2 - y1;\n      return dx * dx + dy * dy;\n    };\n\n    let radianDistance = Math.atan2(p5.mouseY - startTouchY, p5.mouseX - startTouchX);\n    if (radianDistance < 0) radianDistance = radianDistance + p5.TWO_PI;\n\n    if (distSquared(startTouchX, startTouchY, p5.mouseX, p5.mouseY) > 100) {\n      if (radianDistance > p5.TWO_PI - p5.QUARTER_PI || radianDistance < p5.QUARTER_PI) {\n        setDirection(_RIGHT);\n      } else if (radianDistance > p5.QUARTER_PI && radianDistance < p5.HALF_PI + p5.QUARTER_PI) {\n        setDirection(_DOWN);\n      } else if (radianDistance > p5.HALF_PI + p5.QUARTER_PI && radianDistance < p5.PI + p5.QUARTER_PI) {\n        setDirection(_LEFT);\n      } else if (radianDistance > p5.PI + p5.QUARTER_PI && radianDistance < p5.TWO_PI - p5.QUARTER_PI) {\n        setDirection(_UP);\n      }\n    } else {\n      touchDir = NIL;\n    }\n  };\n\n  const drawTouch = () => {\n    const bottomArc = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.QUARTER_PI, p5.HALF_PI + p5.QUARTER_PI);\n\n    const leftArc = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.HALF_PI + p5.QUARTER_PI, p5.PI + p5.QUARTER_PI);\n\n    const topArc = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.PI + p5.QUARTER_PI, p5.TWO_PI - p5.QUARTER_PI);\n\n    const rightArc = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.TWO_PI - p5.QUARTER_PI, p5.QUARTER_PI);\n\n    p5.fill(100);\n    p5.ellipse(startTouchX, startTouchY, arcSize, arcSize);\n    p5.fill(200);\n    if (touchDir === _UP) topArc();\n    if (touchDir === _DOWN) bottomArc();\n    if (touchDir === _LEFT) leftArc();\n    if (touchDir === _RIGHT) rightArc(); // TO-DO: DRAW JOYSTICK THAT IS constrained BY BOUNDARIES OF CONTROL\n\n    p5.fill(50);\n    p5.ellipse(p5.mouseX, p5.mouseY, arcSize / 2, arcSize / 2);\n  };\n\n  const handleTouchEnd = () => {\n    touchControl = false;\n    return false;\n  };\n\n  const handleTouchBegin = () => {\n    startTouchX = p5.mouseX;\n    startTouchY = p5.mouseY;\n    touchControl = true;\n    return false;\n  };\n\n  const handleKeys = (keyType, up, down, left, right) => {\n    if (keyType === right) {\n      setDirection(_RIGHT);\n    }\n\n    if (keyType === down) {\n      setDirection(_DOWN);\n    }\n\n    if (keyType === left) {\n      setDirection(_LEFT);\n    }\n\n    if (keyType === up) {\n      setDirection(_UP);\n    }\n  };\n\n  p5.mousePressed = () => {\n    return handleTouchBegin();\n  };\n\n  p5.touchStarted = () => {\n    return handleTouchBegin();\n  };\n\n  p5.mouseReleased = () => {\n    return handleTouchEnd();\n  };\n\n  p5.touchEnded = () => {\n    return handleTouchEnd();\n  };\n\n  p5.keyTyped = () => {\n    handleKeys(p5.key, \"w\", \"s\", \"a\", \"d\");\n  };\n\n  p5.keyPressed = () => {\n    handleKeys(p5.keyCode, p5.UP_ARROW, p5.DOWN_ARROW, p5.LEFT_ARROW, p5.RIGHT_ARROW);\n  };\n\n  p5.windowResized = () => {\n    p5.resizeCanvas(p5.windowWidth, p5.windowHeight);\n    p5.background(0, 0, 0, 100);\n    fieldOffsetX = p5.windowWidth / 2 - fieldWidth / 2;\n    fieldOffsetY = p5.windowHeight / 2 - fieldHeight / 2;\n    squareSize = fieldWidth / gridResX;\n  };\n};\n\nconst FunkySnake = () => {\n  _s();\n\n  useEffect(() => cleanupFavicon());\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(Helmet, {\n      children: [/*#__PURE__*/_jsxDEV(\"title\", {\n        children: \"Wassup \\uD83D\\uDC0D\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 295,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"meta\", {\n        name: \"viewport\",\n        content: \"width=device-width, initial-scale=1\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 296,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"link\", {\n        rel: \"icon\",\n        href: \"data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>\\uD83D\\uDC0D</text></svg>\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 297,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 294,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(P5Wrapper, {\n      sketch: sketch\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 299,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n\n_s(FunkySnake, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n\n_c = FunkySnake;\nexport default FunkySnake;\n\nvar _c;\n\n$RefreshReg$(_c, \"FunkySnake\");","map":{"version":3,"sources":["/Users/floris.veldhuizen/Documents/GitHub/florisveldhuizen.github.io/src/pages/FunkySnake.jsx"],"names":["useEffect","ReactP5Wrapper","Helmet","cleanupFavicon","P5Wrapper","sketch","p5","fieldWidth","fieldHeight","gridResX","gameSpeed","snakeSize","NIL","_RIGHT","_DOWN","_LEFT","_UP","fieldOffsetX","fieldOffsetY","squareSize","gridResY","maxLength","lastDir","startTouchX","startTouchY","touchControl","touchDir","arcSize","isFirstMove","preMove","curDir","curLoc","bodyParts","bodyLength","death","iterationCounter","snaccPos","_frameRate","Math","floor","highScore","setup","frameRate","createCanvas","windowWidth","windowHeight","background","spawnSnacc","draw","calcTouch","calcNewPos","drawGrid","drawPlayer","drawSnacc","drawTouch","reset","drawScore","fill","rect","stroke","i","j","fontSize","curScore","textSize","textAlign","RIGHT","text","String","fromCodePoint","LEFT","returnRandomPos","xPos","random","yPos","overlap","some","part","returnAvailablePos","gridObject","copyParts","Array","forEach","_","keys","key","value","Object","entries","keyInt","parseInt","filter","elem","length","availableKeys","availableX","availableY","shift","console","error","push","colorInterval","index","setDirection","dir","abs","distSquared","x1","y1","x2","y2","dx","dy","radianDistance","atan2","mouseY","mouseX","TWO_PI","QUARTER_PI","HALF_PI","PI","bottomArc","arc","leftArc","topArc","rightArc","ellipse","handleTouchEnd","handleTouchBegin","handleKeys","keyType","up","down","left","right","mousePressed","touchStarted","mouseReleased","touchEnded","keyTyped","keyPressed","keyCode","UP_ARROW","DOWN_ARROW","LEFT_ARROW","RIGHT_ARROW","windowResized","resizeCanvas","FunkySnake"],"mappings":"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","sourcesContent":["import { useEffect } from \"react\";\nimport { ReactP5Wrapper } from \"react-p5-wrapper\";\nimport { Helmet } from \"react-helmet-async\";\nimport { cleanupFavicon, P5Wrapper } from \"./helper\";\n\nconst sketch = (p5) => {\n  /*\n  Made by: Floris Veldhuizen\n  Queuing of moves was adapted from: https://github.com/patorjk/JavaScript-Snake/blob/master/js/snake.js\n  */\n\n  // PARAMS\n  const fieldWidth = 400;\n  const fieldHeight = 400;\n  const gridResX = 14;          // How many squares fit in a row  (default: 14)\n  const gameSpeed = 13;         // Amount of frames per second    (default: 12)\n  const snakeSize = 5;\n\n  // GLOBAL VARIABLES\n  const NIL     = -1;\n  const _RIGHT  = 0;\n  const _DOWN   = 1;\n  const _LEFT   = 2;\n  const _UP     = 3;\n\n  // PRECALCULATED VALUES\n  let fieldOffsetX, fieldOffsetY, squareSize, gridResY, maxLength, lastDir;\n\n  // TOUCH CONTROLS\n  let startTouchX, startTouchY;\n  let touchControl = false;     // If true, the touch controls are displayed on screen\n  let touchDir = NIL;\n  const arcSize = 120;          // Diameter of the touch controls\n\n  let isFirstMove = true;\n  let preMove = NIL;\n  let curDir = _RIGHT;\n  let curLoc = [0,0];\n  let bodyParts = [];\n  let bodyLength = snakeSize - 1;\n  let death = false;\n  let iterationCounter = 0;\n  let snaccPos = [0,0];\n  let _frameRate = Math.floor(60 / gameSpeed); // Assuming 60 fps\n  let highScore = 0;\n\n  p5.setup = () => {\n    p5.frameRate(60);\n    p5.createCanvas(p5.windowWidth, p5.windowHeight);\n    p5.background(0,0,0,100);\n    fieldOffsetX = (p5.windowWidth/2)-(fieldWidth/2);\n    fieldOffsetY = (p5.windowHeight/2)-(fieldHeight/2);\n    squareSize = fieldWidth / gridResX;\n    gridResY = Math.floor(fieldHeight / squareSize);\n    maxLength = gridResX * gridResY;\n    spawnSnacc();\n  }\n\n  p5.draw = () => {\n    if (touchControl) calcTouch();\n    if (iterationCounter > _frameRate) {\n      p5.background(0,0,0,100);\n      calcNewPos();\n      drawGrid();\n      drawPlayer();\n      drawSnacc();\n      iterationCounter = 0;\n    }\n    if (touchControl) drawTouch();\n    if (death) reset();\n    iterationCounter++;\n    drawScore();\n  }\n\n  const reset = () => {\n    p5.fill(255);\n    p5.rect(0,0,p5.windowWidth,p5.windowHeight);\n    p5.background(0,0,0,100);\n    bodyLength = snakeSize - 1;\n    bodyParts = [];\n    death = false;\n  }\n\n  const drawGrid = () => {\n    p5.stroke(255)\n    p5.fill(0);\n    for (let i = 0; i < gridResX; i++) { // x-axis\n      for (let j = 0; j < gridResY; j++) { // y-axis\n        p5.rect(i * squareSize + fieldOffsetX, j * squareSize + fieldOffsetY, squareSize, squareSize);\n      }\n    }\n  }\n\n  const drawScore = () => {\n    const fontSize = 30;\n    const curScore = bodyLength - (snakeSize - 1);\n    if(curScore > highScore) highScore = curScore;\n    p5.textSize(fontSize);\n    p5.fill(255)\n    // Highscore\n    p5.textAlign(p5.RIGHT);\n    p5.text(`${String.fromCodePoint(0x1F3C6)}: ${highScore}`, fieldOffsetX + fieldWidth, fieldOffsetY - fontSize);\n    // Current score\n    p5.textAlign(p5.LEFT);\n    p5.text(`${String.fromCodePoint(0x1F36C)}: ${curScore}`, fieldOffsetX, fieldOffsetY - fontSize);\n  }\n\n  const spawnSnacc = () => {\n    // TO-DO: use maxLength to determine when the game is over\n    const returnRandomPos = () => {\n      const xPos = Math.floor(Math.random() * gridResX);\n      const yPos = Math.floor(Math.random() * gridResY);\n      const overlap = bodyParts.some(part => (part[0] === xPos && part[1] === yPos));\n      return overlap ? returnRandomPos() : [xPos, yPos];\n    }\n\n    const returnAvailablePos = () => {\n      const gridObject = {};\n      const copyParts = [...bodyParts];\n      [...Array(gridResX)].forEach((_,i) => gridObject[i] = [...Array(gridResY).keys()]);\n      for (const [key, value] of Object.entries(gridObject)) {\n        const keyInt = parseInt(key);\n        gridObject[key] = value.filter(elem =>\n          !copyParts.some(part => part[0] === keyInt && part[1] === elem)\n        )\n        if (gridObject[key].length < 1) delete gridObject[key];\n      }\n      const availableKeys = Object.keys(gridObject);\n      const availableX = parseInt(availableKeys[Math.floor(Math.random() * availableKeys.length)]);\n      const availableY = gridObject[availableX][Math.floor(Math.random() * gridObject[availableX].length)];\n      return [availableX, availableY];\n    }\n\n  return snaccPos = bodyLength < maxLength / 2 ? returnRandomPos() : returnAvailablePos();\n  }\n\n  const drawSnacc = () => {\n    p5.textSize(32);\n    p5.text(`${String.fromCodePoint(0x1F36C)}`, snaccPos[0] * squareSize + fieldOffsetX, (snaccPos[1] + 0.9) * squareSize + fieldOffsetY);\n  }\n\n  const calcNewPos = () => {\n    // Set lastDir and check for queued moves\n    lastDir = curDir;\n    if (preMove !== NIL) {\n      curDir = preMove;\n      preMove = NIL;\n    }\n    isFirstMove = true;\n\n    // Calculate new position of body based on direction\n    if      (lastDir === _UP)    { curLoc[1]-- }\n    else if (lastDir === _DOWN)  { curLoc[1]++ }\n    else if (lastDir === _LEFT)  { curLoc[0]-- }\n    else if (lastDir === _RIGHT) { curLoc[0]++ }\n\n    // Boundary check\n    if      (curLoc[1] < 0) { curLoc[1] = gridResY - 1 }\n    else if (curLoc[1] > gridResY - 1) { curLoc[1] = 0 }\n    else if (curLoc[0] < 0) { curLoc[0] = gridResX - 1 }\n    else if (curLoc[0] > gridResX - 1) { curLoc[0] = 0 }\n\n    // Shift the snake body\n    if (bodyParts.length > bodyLength) { bodyParts.shift(); }\n\n    // Death 💀 check\n    bodyParts.forEach(part => {\n      if (curLoc[0] === part[0] && curLoc[1] === part[1]) {\n      death = true;\n      console.error(`U DEAD ${String.fromCodePoint(0x1F480)}`);\n      }\n    });\n\n    // Set all bodyparts\n    bodyParts.push([...curLoc]);\n\n    // Snacc 🍬 check\n    if (curLoc[0] === snaccPos[0] && curLoc[1] === snaccPos[1]) {\n      bodyLength++;\n      spawnSnacc();\n    }\n  }\n\n  const drawPlayer = () => {\n    const colorInterval = Math.floor(155 / bodyLength);\n    bodyParts.forEach((part,index) => {\n      p5.fill(index * colorInterval + 100,0,0);\n      p5.rect(part[0] * squareSize + fieldOffsetX, part[1] * squareSize + fieldOffsetY, squareSize, squareSize);\n    });\n  }\n\n  const setDirection = dir => {\n    if (curDir !== lastDir) { preMove = dir }\n    if (Math.abs(dir - lastDir) !== 2 && isFirstMove) {\n      curDir = dir;\n      isFirstMove = false;\n    }\n    touchDir = dir;\n  }\n\n  const calcTouch = () => {\n    const distSquared = (x1, y1, x2, y2) => {\n      let dx = x2 - x1;\n      let dy = y2 - y1;\n      return dx * dx + dy * dy;\n    }\n    let radianDistance = Math.atan2(p5.mouseY-startTouchY, p5.mouseX-startTouchX);\n    if (radianDistance < 0) radianDistance = radianDistance + p5.TWO_PI;\n    if(distSquared(startTouchX, startTouchY, p5.mouseX, p5.mouseY) > 100) {\n      if      (radianDistance > p5.TWO_PI - p5.QUARTER_PI || radianDistance < p5.QUARTER_PI)          { setDirection(_RIGHT)}\n      else if (radianDistance > p5.QUARTER_PI && radianDistance < p5.HALF_PI + p5.QUARTER_PI)         { setDirection(_DOWN) }\n      else if (radianDistance > p5.HALF_PI + p5.QUARTER_PI && radianDistance < p5.PI + p5.QUARTER_PI) { setDirection(_LEFT) }\n      else if (radianDistance > p5.PI + p5.QUARTER_PI && radianDistance < p5.TWO_PI - p5.QUARTER_PI)  { setDirection(_UP)   }\n    } else {\n      touchDir = NIL;\n    }\n  }\n\n  const drawTouch = () => {\n    const bottomArc = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.QUARTER_PI, p5.HALF_PI + p5.QUARTER_PI);\n    const leftArc   = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.HALF_PI + p5.QUARTER_PI, p5.PI + p5.QUARTER_PI);\n    const topArc    = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.PI + p5.QUARTER_PI, p5.TWO_PI - p5.QUARTER_PI);\n    const rightArc  = () => p5.arc(startTouchX, startTouchY, arcSize, arcSize, p5.TWO_PI - p5.QUARTER_PI, p5.QUARTER_PI);\n\n    p5.fill(100);\n    p5.ellipse(startTouchX, startTouchY, arcSize, arcSize);\n    p5.fill(200);\n    if (touchDir === _UP)    topArc();\n    if (touchDir === _DOWN)  bottomArc();\n    if (touchDir === _LEFT)  leftArc();\n    if (touchDir === _RIGHT) rightArc();\n\n    // TO-DO: DRAW JOYSTICK THAT IS constrained BY BOUNDARIES OF CONTROL\n    p5.fill(50);\n    p5.ellipse(p5.mouseX, p5.mouseY, arcSize/2, arcSize/2);\n  }\n\n  const handleTouchEnd = () => {\n    touchControl = false;\n    return false;\n  }\n\n  const handleTouchBegin = () => {\n    startTouchX = p5.mouseX;\n    startTouchY = p5.mouseY;\n    touchControl = true;\n    return false;\n  }\n\n  const handleKeys = (keyType, up, down, left, right) => {\n    if (keyType === right) { setDirection(_RIGHT)}\n    if (keyType === down)  { setDirection(_DOWN) }\n    if (keyType === left)  { setDirection(_LEFT) }\n    if (keyType === up)    { setDirection(_UP)   }\n  }\n\n  p5.mousePressed = () => {\n    return handleTouchBegin();\n  }\n\n  p5.touchStarted = () => {\n    return handleTouchBegin();\n  }\n\n  p5.mouseReleased = () => {\n    return handleTouchEnd();\n  }\n\n  p5.touchEnded = () => {\n    return handleTouchEnd();\n  }\n\n  p5.keyTyped = () => {\n    handleKeys(p5.key, \"w\", \"s\", \"a\", \"d\");\n  }\n\n  p5.keyPressed = () => {\n    handleKeys(p5.keyCode, p5.UP_ARROW, p5.DOWN_ARROW, p5.LEFT_ARROW, p5.RIGHT_ARROW);\n  }\n\n  p5.windowResized = () => {\n    p5.resizeCanvas(p5.windowWidth, p5.windowHeight);\n    p5.background(0,0,0,100);\n    fieldOffsetX = (p5.windowWidth/2)-(fieldWidth/2);\n    fieldOffsetY = (p5.windowHeight/2)-(fieldHeight/2);\n    squareSize = fieldWidth / gridResX;\n  }\n}\n\nconst FunkySnake = () => {\n  useEffect(() => (cleanupFavicon()));\n  return (\n    <>\n      <Helmet>\n        <title>Wassup &#x1F40D;</title>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <link rel=\"icon\" href=\"data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>🐍</text></svg>\" />\n      </Helmet>\n      <P5Wrapper sketch={sketch} />\n    </>\n  );\n};\n\nexport default FunkySnake;\n"]},"metadata":{},"sourceType":"module"}